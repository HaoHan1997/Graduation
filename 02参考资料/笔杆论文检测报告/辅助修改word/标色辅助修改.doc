
<html xmlns:o="urn:schemas-microsoft-com:office:office"xmlns:w="urn:schemas-microsoft-com:office:word"xmlns="http://www.w3.org/TR/REC-html40">
<body>
    <p>    本科毕业设计(论文)</p><p>    题目:城市道路交通信号模糊控制的研究</p><p>    院(系):电子信息工程学院</p><p>    专业:电气工程及其自动化</p><p>    班级:120424</p><p>    学生:成锐林</p><p>    学号:120424102</p><p>    指导教师:贺为婷</p><p>    2016年5月19日</p><p>    城市道路交通信号模糊控制的研究</p><p>    摘要</p><p>    <span style='color:red;'>模糊控制是一种无模型的智能控制方法,它靠结合人的思维和经验进行交通控制来满足实时性的要求,是一种大有前途的城市交通控制方式。自从1977年希腊学者C.P.Mamdani提出单交叉路口交通信号灯模糊控制方法以来,模糊控制技术在交通方面的研究逐</span>步得到认可,但该方面的研究大多集中在单交叉路口的两相位模糊控制方面。</p><p>    <span style='color:red;'>基于上述考虑,本文提出了一种交叉路网交通灯的可变相位的模糊控制方法。该方法根据通行权转移度来确定通行相位及通行时间。仿真结果表明,该算法具有良好的控制效果。</span></p><p>    <span style='color:red;'>1.方法是建立在相位顺序可变的基础上,即由当前交通情况决定相位的轮换次序,同时控制绿灯时延的长短,将有利于提高交叉路口的通行效率。改善模糊控制性能的最有效的方法是优化模糊控制规则,通常,模糊控制规则是通过将人的操作经验转化为模糊语言形式获得,带有相当的主观性,可运用遗传算法优化规则。</span></p><p>    <span style='color:red;'>2.模糊控制方法,控制规则少,控制效果有一定的提高,是一种城市单交叉路口交通信号灯模糊控制的有效方法,分析和计算机仿真表明,它优于感应式控制方法。<br />关键词:交通量,</span>信号灯,模糊控制,仿真,交叉口。</p><p>    Fuzzy control of urban road traffic signal <br />Abstract</p><p>    Fuzzy control is an intelligent model-free method of controlling it by binding to human thinking and experience <span style='color:red;'>traffic control to meet real-time requirements, is a </span>promising urban traffic control. Since 1977, the Greek scholar C.P.Mamdani proposed single intersection traffic signal fuzzy control method since Fuzzy technology in traffic control gradually recognized, but research in this field are mostly concentrated in the intersection of the two single-phase Fuzzy Control.</p><p>    Based on these considerations, we propose a fuzzy variable phase control method cross the road network of traffic lights. The method to determine the degree of transfer of right of way access phase and transit <span style='color:red;'>time. The simulation results show that the algorithm has </span>good control effect.</p><p>    1. The method is based on the phase sequence variable, based on the current traffic situation that is determined by the phase of the order of rotation, while controlling the length of the green light delay, it will help <span style='color:red;'>to improve the efficiency of traffic intersection. The most effective way to improve performance is to </span>optimize the fuzzy control fuzzy control rules, in general, fuzzy control rules by the human experience into fuzzy linguistic form obtained with quite subjective, can use the genetic algorithm optimization rules.</p><p>    <span style='color:red;'>2. fuzzy control method, less control rules to </span>control the effect some improvement, is an effective method of urban single intersection traffic signal fuzzy control,<span style='color:red;'> analysis and computer simulations show that it is superior </span>induction control method.</p><p>    Key Word: traffic,lights,fuzzy control,simulation,intersection.<br />目录</p><p>    中文摘要 I</p><p>    英文摘要 II</p><p>    1绪论1</p><p>    1.1研究的背景1</p><p>    1.2国内外的研究状况1</p><p>    1.3研究的意义1</p><p>    2交通信号控制基本理论1</p><p>    2.1交通信号及通行行为控制1</p><p>    2.2交通流基本理论1</p><p>    2.2.1交通流的基本参数与关系1</p><p>    2.2.2简单城市道路交通流模型1</p><p>    2.2.3交通流的分布规律1</p><p>    2.3交通信号控制参数和方式1</p><p>    2.3.1交通信号控制的基本参数1</p><p>    2.3.2交通信号的控制方式1</p><p>    3交通信号相位控制1</p><p>    3.1四相位交叉口车辆平均延误计算模型1</p><p>    3.2交叉口车辆平均延误计算模型1</p><p>    4交通信号控制的性能评价指标1</p><p>    5交通信号模糊控制1</p><p>    5.1模糊控制基本原理1</p><p>    5.2模糊控制器的设计1</p><p>    5.3交通信号模糊控制思路1</p><p>    5.4交通信号模糊控制器设计1</p><p>    5.4.1模糊控制输入量与输出量的确定1</p><p>    5.4.2输入、输出变量的模糊化1</p><p>    5.4.3模糊规则的设计1</p><p>    5.4.4信号灯模糊控制算法的具体描述1</p><p>    6交通信号模糊控制的仿真实现1</p><p>    6.1仿真软件简介1</p><p>    6.2基于MATLAB的交通信号模糊控制1</p><p>    7结论1</p><p>    参考文献1</p><p>    致谢1</p><p>    毕业设计(论文)知识产权声明1</p><p>    毕业设计(论文)独创性声明1</p><p>    附录1仿真原理图1</p><p>    附录2源程序清单1</p><p>    附录3外文原文及翻译1</p><p>    1绪论</p><p>    1.1研究的背景</p><p>    <span style='color:red;'>随着经济的快速发展以及城市化进程的加快,城市机动车数量急剧增加,</span>车辆堵寨现象越来越严重,交通问题已成为函待解决的民生问题之一。<span style='color:red;'>由于城市交通系统具有随机性,不确定性及相当的复杂性,</span>传统的交通信号定时控制方案已难以满足当今社会大流量的复杂的交通状况。<span style='color:red;'>因此,专家们提出了采用模糊控制方法实现交通信号的控制。模糊控制不需要建立被控对象的精确数学模型,特别适用于随机的,复杂的城市交通控制。</span>模糊控制模仿交通警察的实际指挥经验,根据交通流量的实际情况执行交通的智能控制,保证了最优的交叉路口利用率,<span style='color:red;'>缩短了车辆的平均延误时间。基于模糊控制的交叉路口信号控制系统的研究,对解决交叉路口车辆堵塞具有重要的现实意义。<br /></span>1.2国内外的研究状况</p><p>    <span style='color:red;'>二十世纪六十年代,世界各国纷纷开始研究针对大范围的区域交通信号协调控制系统,根据各交叉口车流状况建立数学模型,模拟各种交通状况,并优化信号配时问题。</span></p><p>    <span style='color:red;'>近几年,欧盟、美国和日本开战的大型ITS研发计划反映了车路一体化的发展趋势。美国交通部2009年启动了IntelliDrive计划,研究内容主要覆盖了车载通讯及其安全应用等方面,为美国实施下一代ITS的重要战略目标打下基础。日本政府目前正在着手研发SMARTWAY智能交通系统,计划用5年的时间在重要道路上覆盖路况认知传感器、构建智能汽车系统、智能道路系统、车路间协调系统,实现交通信息的实时发布[14]。</span></p><p>    <span style='color:red;'>相对于我国城市快速增长的交通需求,我国交通基础设施发展较为缓慢。因此,如何在现有的交通设施的条件下,采用合理的交通控制手段,保证交通的畅通运行是我国交通信号控制领域的研究目标。二十世纪八十年代,我国引入了交叉口信号控制系统的概念。该领域早起的研究方向定位于实时控制,通过建立精确的数学模型反应交叉口的交通状况,并根据模型确定信号配时方案以及绿信比等信号控制参数[15]。</span></p><p>    <span style='color:red;'>近年来,算法在信号控制系统中也得到了广泛应用。张宗华等人采用了遗传算法优化控制交通网络信号。该方法根据美国联邦高级公路管理局的交通模拟管理软件设置信号时间,采用遗传算法模拟交通网络,获得延时时间,并以此作为对应染色体的适应度评价值。其中,公路网络的一个交通信号对应遗传算法中的一个染色体。采用该方法对三个路口的信号灯进行仿真实验,仿真结果证实了其能有效地联动控制路口信号灯的变化[20]。</span></p><p>    马莹莹等结合道路交通控制的多目标性,建立交通信号周期时长多目标优化模型,<span style='color:red;'>采用多目标连续蚁群算法求解模型,实现交叉口信号优化控制。该模型综合考虑了交叉口的各种交通需求,弥补了传统交叉口交通指标的单一性所产生的信号控制方法的缺陷[21]。</span></p><p>    吴明晖等针对单交叉口交通状况,<span style='color:red;'>提出了一种多种智能控制方法结合的交叉口信号控制模型。该模型采用三层BP人工神经网络预测口车辆到达率,以交通流饱和度理论为基础利用模糊控制器调整交叉口绿灯信号时间[21]。<br /></span>1.3研究的意义</p><p>    <span style='color:red;'>智能交通系统(ITS,intelligent transport system)是指人们将现金的信息技术、数据通信传输技术、点子控制技术、传感器技术以及计算机处理技术等有效地综合运用于整个传输体系中,从而建立起的一种在大范围内、全方位发挥作用的实时、准确、高效的传输综合管理系统。[1-3]</span></p><p>    <span style='color:red;'>当前我国大多数城市的平均行车速度已降至20km/h以下,同时,由于车辆速度过慢、尾气排放增加,使得城市的空气质量进一步恶化。为了缓解经济发展给交通带来的压力,使现有的资源发挥出最大作用,我国政府加大了智能交通系统的研究和建设力度。采用智能交通系统的交叉口具有两大优点:</span></p><p>    <span style='color:red;'>首先,有效提高了交通运输效益,使得交通拥挤降低20%,延误损失减少10%~25%,车祸降低50%~80%,油料消耗减少30%;</span></p><p>    其次,对解决道路交通拥堵、<span style='color:red;'>减少财产损失、减少环境污染,增强交通安全性,合理利用土地与能源[4-6]</span></p><p>    <span style='color:red;'>交叉路口城市机动车辆的不断增加,使得车辆堵塞现象越来越严重,当前大部分城市仍然采用的定时控制十字路口交通灯的控制方法。交通控制就是确定</span>交叉路口红绿的信号时,使通过交叉的车辆延误尽可能小。<span style='color:red;'>传统的控制一般是采用模型控制或预先认为地设定多套方案,由于道路上的车流量具有较大的随机性,所实施的相位控制也应随车流量的不同而相应变化,但是交通警察在实际的交通指挥中可以根据实际情况来控制交通,如果东西方向的车流量大,则其放行时间长;南北方向车流量小,则其放行时间短[7-8]。</span></p><p>    <span style='color:red;'>模糊控制理论在交通系统中的应用模仿了交警的控制经验实现智能控制,可以使车辆等待延误时间最小,因此基于模糊控制理论的交叉路口信号灯控制系统的研究对解决交叉路口车辆堵塞具有重要意义。<br /></span>2交通信号控制基本理论</p><p>    <span style='color:red;'>交通信号是在空间上无法实现车辆分离的地方,在时间上对交通流分配通行权的一种交通指挥措施。灯光信号通过交通信号灯的红色来指挥交通。目前世界各国信号灯的含义基本上进行了统一规定。我国规定如下:<br />(1)红灯:表示禁止该灯面对方向的车辆和行人通行;</span></p><p>    <span style='color:red;'>(2)绿灯:表示允许该灯所面对方向的车辆和行人通行,而转弯的车辆在不妨碍直行车辆以及已经进入人行通道的行人可以继续通行;</span></p><p>    <span style='color:red;'>(3)黄灯:表示不允许该灯所对方向的车辆和行人同通行。但是,已经越过停止线的车辆以及已经进入人行通道的行人可以继续通行;<br />(4)绿色箭头:表示该灯对应方向的车辆可以按照箭头所指方向通行。</span></p><p>    <span style='color:red;'>在道路右边没有人行横道和直行车辆的情况下,右转车辆在遇到黄灯或红灯时,可以在不妨碍放行车辆和行人通行的条件下通行。<br />2.1交通信号及通行行为控制</span></p><p>    交叉路口通行行为控制是道路的交通控制的重点。<span style='color:red;'>使用交通信号灯对交叉路口处人和车辆的通行行为控制是道路交通系统中最具代表性的控制方法。这种控制方法借助自动化设备来控制交通信号灯等色的变换,针对人发出通行停止的行为控制命令,实现对交叉路口人和车辆通行行为的实时控制</span>。</p><p>    <span style='color:red;'>交叉路口机动车按交通规则直行、右转、左转自由通行交叉路口,不同车辆通行行驶轨迹在交叉口区域形成了多个冲突点,这些冲突点分为交叉点和合流点。如图2.1所示。<br />图2.1交叉路口示示意图</span></p><p>    2.2交通流基本理论</p><p>    <span style='color:red;'>交通流理论是分析研究道路上行人和机动车辆(主要是汽车)在个别或成列行动中的规律,探讨车流流量、流速和密度之间的关系,以求减少交通时间的延误、事故的发生和提高道路交通设施使用效率的理论。始于50年代。是交通工程理论的基础和其新发展的领域之一。</span><br />2.2.1交通流的基本参数与关系</p><p>    交通流是指各个进道口的车辆,主要参数有交通量q,车流密度k,行驶速度v。</p><p>    <span style='color:red;'>交通量q是指在一段时间内通过某进道口断面的车辆数,单位是&quot;辆/车道&quot;。</span>车流密度k是指一段时间内某车道的平均车辆数,单位是&quot;辆/千米/车道&quot;。行驶速度v指的是一段时间内某车道车辆行驶速度的平均值,单位是&quot;km/h&quot;。他们的关系是<br />q=k&middot;v</p><p>    2.2.2简单城市道路交通流模型</p><p>    <span style='color:red;'>城市道路的特点是存在大量的平面交叉口,不同方向车流的冲突也在发生。在研究城市道路交通重点应该集中在交叉路口的交通</span>特性上。如图2.2为单交叉路口的道路交通流模型。<br />图2.2单交叉路口的道路交通流模型</p><p>    2.2.3交通流的分布规律</p><p>    <span style='color:red;'>交通流在一定的观测周期内到达的车辆数服从泊松分布、二项分布、负二项分布等离散型分布规律。</span></p><p>    (1)泊松分布:车辆(或人)的到达时随机的,相互之间影响不大,也不受外界干扰,这种情况发生在交通流密度不大的时候。<span style='color:red;'><br />(2)二项分布:车辆比较拥挤、自由行使机会不多的车流。</span></p><p>    <span style='color:red;'>(3)负二项分布:到达量波动很大的车流。</span></p><p>    2.3交通信号控制参数和方式</p><p>    2.3.1交通流的分布规律</p><p>    <span style='color:red;'>交通信号控制的基本参数包括相位、周期、</span>绿信比等。交通控制系统的控制目标就是通过确定控制参数来达到调控道路流量的目的。<br />(1)相位</p><p>    为了避免交叉路口各个方向交通流之间的冲突,通常可以在时间和空间上划分车流。在空间上采用高架桥,在时间上采用分时通行。在某一段时间内,交叉口的某一支或多支交通流具有通行权,与之冲突的交通流不能通行。这一时间段称为信号相位,简称相位。相位时间包括绿灯时间和黄灯时间。<br />(2)周期</p><p>    周期是各个信号灯全部显示一遍的时间和。周期是决定控制定时信号交通效益的关键控制参数。周期时间不能太短,否则不能保证各个方向的车流通行。周期时间也不能够太长,会导致司机错误的判断,导致不可预料的危险。理想情况是每个相位绿灯时间恰好该入口等待车辆全部放行完毕。<br />(3)绿信比</p><p>    <span style='color:red;'>绿信比是一个信号相位的有效绿灯时长与该相位所属周期时长的比值。设某相位有效绿灯时长为Tgi,该相位所属周期时长为C,则绿信比&lambda;为:<br />&lambda;=Tgi/C</span></p><p>    显然0&lt;&lambda;&lt;1,绿信比对疏通交通流十分重要。<span style='color:red;'>合理的绿信比可以使各个方向车流停车次数和等待延误时间减至最小。<br /></span>2.3.2交通信号的控制方式</p><p>    <span style='color:red;'>交通信号控制有各种各样的方式,其分类也有很多种。按控制范围分类,可以将信号控制分为点控、线控和面控。按控制方法分类,可以分为定时控制、感应控制等。</span></p><p>    <span style='color:red;'>(1)单交叉口信号控制(点控制):每个交叉口的交通控制信号只按照该交叉口的交通情况独立运行,不与其邻近交叉口的控制信号有任何联系的,称为单个交叉口交通控制,即&quot;点控制。这是交叉口交通信号控制的最基本形式。</span></p><p>    <span style='color:red;'>(2)干道交通信号协调控制(线控制):把干道上若干个连续交叉口的交通信号通过一定的方式联结起来,同时对各交叉口设计一种相互协调的配时方案,各交叉口的信号灯按此协调方案联合运行,使车辆通过这些交叉口时,不致经常遇上红灯,称为干道信号协调控制。也叫&quot;绿波&quot;信号控制,俗称&quot;线控制&quot;。</span></p><p>    <span style='color:red;'>(3)区域交通信号协调控制(面控制):以某个区域中所有信号控制交叉口作为协调控制的对象,简称为区域交通信号控制系统,俗称&quot;面控制&quot;。</span></p><p>    <span style='color:red;'>(4)定时控制:交叉口信号控制机均按事先设定的配时方案运行,也称为定周期控制。<br />本文主要研究基于定时控制与模糊控制相结合的单点交通信号的</span>控制。</p><p>    3交通信号相位控制</p><p>    在一个信号变化周期内,把每一种可能通过的控制(即对各进口通道不同方向所显示的不同信号灯颜色的组合)成为一个信号相位。一般信号灯控制多采用两个相位,即二项制,东西通行南北禁止为第一相位,<span style='color:red;'>东西禁止南北通行为第二相位。二相位可以消除一些通行冲突点,但没有消除&quot;左-直&quot;的通行冲突。</span>这时可以设置专用信号灯相位,<span style='color:red;'>这就采用了三相信号灯控制,相位越多,通行权分配越细,冲突点就越少。<br />3.1四相位交叉口几何模型描述</span></p><p>    <span style='color:red;'>如图3.1所示,这是一个典型的四相位交叉口交通流模型,该交叉口有四个进口道,每个进口道有三支车流(左转,直行和右转),</span>除了比较特殊的情况,<span style='color:red;'>右转车辆可以不受信号灯的约束通过交叉路口。实施多相位控制可以消除直行车辆和左转车辆的冲突,提高行车的安全性。<br />图3.1四相位交叉口交通流模型</span></p><p>    <span style='color:red;'>为了实现交通的实时控制,需要在每个车道上安装两个感应线圈检测器来获得实时的交通流信息。第一个检测器放在停车线的位置,第二个检测器安装在距离第一个检测器180米的位置,交叉口车辆检测器的安装如图3.1所示设置。设置小汽车的平均长度为4.5米,行车的安全距离5.5米,停车时的间距为1.5米,则检测器可以检测的车辆可达30PCU,能够满足实际交叉口排队长度的要求。</span>为了方便对比,一般交通信号感应控制检测器安装如下图3.2所示设置。<br />图3.1模糊控制方法的检测器设置</p><p>    图3.2感应控制方法的检测器设置</p><p>    3.2交叉口车辆平均延误计算模型</p><p>    <span style='color:red;'>交通信号的控制是为了减小车辆通过交叉口的延误,车辆的平均延误也在一定程度上反映了交叉口的通行能力,这里以车辆的平均延误作为交叉口信号控制的性能评价指标,平均延误小代表控制性</span>能好。</p><p>    <span style='color:red;'>到达交叉口各个方向车辆是随机的,非拥挤交通流的车辆数服从松柏分布,拥挤交通流车辆数服从二项分布。在每个相位中,信号周期有&quot;有效红灯&quot;、&quot;有效绿灯&quot;和&quot;黄灯&quot;。假设当在红灯变为绿灯后排队的车辆以饱和流率驾驶离开交叉口,车辆的延误计算模型为:<br />qm=1,如果在第m秒内有1辆车到达0,</span>否则</p><p>    <span style='color:red;'>令Qmr为红灯相位第m秒的排队车辆数,则</span></p><p>    Qmr=i=1kQig+j=1mqij</p><p>    <span style='color:red;'>式中:Qig为当前红灯相位中第支车流在前绿灯信号结束时滞留的车辆数;qij为当前红灯相位第i支车流在红灯信号第j秒内到达的车辆数;k为红灯相位车流数,对于四相位交叉口,不考虑右转车流,则k=6。</span></p><p>    <span style='color:red;'>若n为当前红灯相位本周期的红灯时间(秒),则红灯相位的车辆总延误Dr为:<br />Dr=m=1ni=1k(Qig+j=1mqij)</span></p><p>    <span style='color:red;'>设qi为饱和流量,则当前绿灯相位在绿灯信号第m秒时,还未通过交叉口车辆数为:<br />Qmg=i=1k(Qir+j=1mqij-qsm)</span></p><p>    <span style='color:red;'>式中:Qir为当前绿灯相位第i支车流在前红灯时间等待的车辆数;qij为当前绿灯相位第i支车流在本周期绿灯信号第j秒内到达的车辆数;k为绿灯相位车流数,对于四相位交叉口,不考虑右转车流,k=2。</span><br />zi=1,&amp;Qir+j=1mqij-qsm&gt;00,&amp;否则</p><br /><p>    绿灯相位车辆总延误Dg为</p><p>    Dg=m=1gi=1kzi(Qir+j=1mqij-qsm)</p><p>    <span style='color:red;'>式中:g为该周期内绿灯时间(秒)。第x个周期的总延误为:</span></p><p>    Dx=Dr+Dg</p><p>    y个周期的车辆平均延误为:</p><p>    d=x=1yDxA</p><p>    <span style='color:red;'>式中:A为y个周期交叉口所有方向到达的车辆数。</span></p><p>    4交通信号控制的性能评价指标</p><p>    交通信号控制的评价指标有通行能力或饱和度、停车的次数或停车率、车辆平均延误、排队长度、行程的时间以及油耗等等。不同指标从不同的方向反映了交叉口的通行能力。</p><p>    <span style='color:red;'>(1)通行能力是指在特定的道路条件和交通条件下,单位时间内能够通过一个车道</span>或者道路断面的最多车辆数,也称为道路容量。道路通行能力是道路与交通规划设计以及交通管理的基本依据之一。</p><p>    <span style='color:red;'>(2)停车次数是指一个信号周期内车辆停车次数的总和,停车率就是在一个信号周期内停车的数量占通过交叉口车辆总数的比率。</span></p><p>    (3)车辆平均延误时间是指在交通冲突或者信号控制设施限制的情况下,给车辆带来的时间损失。<span style='color:red;'>延误时间是衡量路口通行效果的重要参数之一,也是在交通中的人最关心的参数指标。韦伯斯特运用排队论和计算机模拟结合的方法,提出了计算交叉路口进口道上车辆随机延误时间公式和平均延误时间公式:<br />车辆随机延误时间公式:</span></p><p>    tr=x22Q(1-x)</p><p>    平均延误时间公式:</p><p>    tu=C(1-&lambda;)22(1-y)</p><p>    定时状态下路口车辆延误时间的修正公式:</p><p>    <span style='color:red;'>t=C(1-&lambda;)22(1-y)+x22Q(1-x)-0.65(CQ2)13x(2+5&lambda;)</span></p><p>    <span style='color:red;'>其中,C是指周期时长,&lambda;是指绿信比,y是指机动车道流量比(y=Q&frasl;Q_s ),Q代表进口机动车道实际流量,Q_s代表进口道饱和流量,x为饱和度,t_r是指车辆随机延误时间,t_u是指车辆平均延误时间。</span></p><p>    (4)排队长度也是交叉口信号控制的一个重要的指标,<span style='color:red;'>目前,车辆在交叉路口停车线后的排队长度计算分为三种情况:</span></p><p>    <span style='color:red;'>1、非饱和情况下,在交通量还没有达到饱和时,采用下面公式计算车辆在停车线后的排队长度:<br />L=L0+LR</span></p><p>    式中</p><p>    L -绿灯开始前车辆排队长度;</p><p>    <span style='color:red;'>L0-红灯开始前车辆排队长度;</span></p><p>    L0-红灯期间车辆排队长度,有</p><p>    <span style='color:red;'>L0=exp-43&times;u&times;T&times;qs0.5&times;1-xx/[2(1-x)]</span></p><p>    LR=qv&times;T-tEG=qv&times;T&times;1-tEGT=qv&times;T&times;(1-u)</p><p>    上两式中:</p><p>    qs -每单位路宽的饱和流量;</p><p>    qv -每单位路宽的到达流量;</p><p>    T -信号周期;</p><p>    tEG -有效绿灯时间</p><p>    <span style='color:red;'>2、饱和条件下,在过饱和条件下的车辆排队长度可根据下述公式确定:</span></p><p>    L=qc4(x-1+(x-1)2+12(x-x')&lambda;&times;t)</p><p>    式中:</p><p>    qc为交叉口的通行能力。</p><p>    x'=0.67+qs&times;tEG600</p><p>    有些指标与设立交叉口信号灯的目标是一致的,但也会有负面影响。例如车辆平均延误时间越少,<span style='color:red;'>代表着单位时间通过交叉口的车辆越多,停车的次数越少以及能耗越低,但是交通可能就越不安全。</span>提高通行能力是高效缓解交通矛盾的关键,<span style='color:red;'>通行能力越高就越有力的避免交通事故。所以说平均延误是大多数国家评价交叉口通行能力的主要指标。能够使单个交叉路口或者整个交通网络得到良好的信号时间分配市交通信号控制的最终目标。<br /></span>5交通信号模糊控制</p><p>    5.1模糊控制基本原理</p><p>    在常规控制方法中,人们用传递函数或逻辑方程来准确地描述系统的输入输出特性。<span style='color:red;'>而在模糊控制中,则通过模糊逻辑近似推理方法来实现对系统的控制。</span>流程如图5.1。<br />(1)模糊化</p><p>    通常输入量都是连续变化的值,是非模糊量,必须先转化为模糊量才能进行模糊推理。模糊化就是将输入量变化范围划分成几个有限的级别,使得输入量对应几个有限个模糊集,在根据隶属函数的定义求出输出量对模糊集的隶属度,这样就把输入变量转化成了模糊变量。<br />(2)模糊推理</p><p>    模糊推理是模糊控制的核心。模糊推理采用语言型模糊控制的方法对输入做出决策,采用&quot;IF.TEHN.<span style='color:red;'>&quot;的语言形式。IF部分是规则的前提,THEN部分是规则的结论。已知前提求结论是前向推理,反之为后向推理。</span></p><p>    <span style='color:red;'>模糊推理由条件集合,推理和累加三部分组成。首先根据模糊输入计算每条规则的满足程度(聚合),然后根据满足程度推断单一规则的输出大小(推断),最后把所有规则的输出累加,得到总的输出大小(累加)。<br />(3)反模糊化</span></p><p>    反模糊化是将模糊推理的输出模糊值转化为控制系统的精确的输出变量,这样才能采用控制。其实质是将模糊集合映射到普通集合的过程。<span style='color:red;'>常见的反模糊化方法有加权平均法、最大隶属度法和取中位数法。</span></p><p>    <span style='color:red;'>加权平均法又称为面积重心法,简称为重心法。通过取出模糊集合隶属度函数曲线与横坐标轴所围成的面积所对应的输出作为精确的输出。<br /></span>5.2模糊控制器的设计</p><p>    5.3交通信号模糊控制思路</p><p>    既然车辆的平均延误是评价交叉口服务水平的最主要指标,而车辆排队长度是延误时间增加的主要因素,所以车辆排队长度如果越长,越容易引起车辆阻塞和平均延误时间的增加。</p><p>    传统定时控制与感应控制都采用的是相位固定的方法,这一方法明显存在误差。当固定下一相位车流量很小的时候,<span style='color:red;'>这种控制规则要给下一相位至少分配最小的绿灯时间,中间还包括了绿灯转换消耗掉了的黄灯时长,如果后面相位车道有很大车流量,就必然会导致车辆平均延误增大。</span></p><p>    <span style='color:red;'>采用模糊控制方法,当绿灯相位通行时间结束,分别以当前的绿灯相位车道的车辆排队长度S_n和当前红灯相位上各车道中最大的车辆排队长度Q_nmax作为</span>输入变量,求出通行权转移度P,若P大于某个阈值,就将下一次通行权分配给车辆排队长度最大的车道相位(如果不能确定唯一通行的相位,<span style='color:red;'>还需要在这个方法上做出其他的决策)。如果P没有大于这个阈值,就再以当前相位绿灯已通行时间t和通行权转移度作为P的模糊控制的两个输入变量,得到当前相位绿灯延时△ t,即绿灯时间延长△ t。如果△ t加上当前相位绿灯时间已经达到了绿灯时间的上线,就进行相位的跳转,将通行权给当前红灯相位上各车道中最大车辆排队长度Q_nmax所在的车道的相位。同时考虑到某个车道在很长的时间里面也只有很少车辆到来这个特殊的情况,为了防止这个车道的车辆等待时间过长,设定一个最长的红灯时间,如果这个车道的相位的红灯时间超过上限,则在当前相位的绿灯时延结束之后,优先把通行权分配给这个红灯相位。然后重复执行上述方案。</span></p><p>    <span style='color:red;'>这种经过△ t时间重新圈定绿灯时延的方法可以使得绿灯时长分配根据路口的实际交通的流量有自适应性,保证了通行机会的均等性和通行分配时间的合理性,从而缩短了延误时间。<br />5.4交通信号模糊控制器设计</span></p><p>    5.4.1模糊控制输入量与输出量的确定</p><p>    <span style='color:red;'>各个方向车辆和行人交通流是交通信号的控制对象,绿灯时间和红灯时间决定了哪个方向的这两个交通流能够能够通行以及能够通行的时长。如果把信号相位考虑进来,那么绿灯时间就是每个相位唯一要考虑的参数,对于交叉口来说,如果各个相位的绿灯可以时间确定,那么这个信号周期也就确定了。由交通控制理论可以知道,某一交叉路口信号周期C由下面公式确定:<br /></span>C=Gi+Yi+Ri+⋯+Gn+Yn+Rn=inGi+Yi+Ri</p><p>    上式中:</p><p>    <span style='color:red;'>Gi -相位设定的绿灯时间,单位s;</span></p><p>    Yi -各相位设定的黄灯时间,一般取3~5s;</p><p>    <span style='color:red;'>Ri -各相位设定的红灯时间,单位s;</span></p><p>    n -信号相位总数;</p><p>    <span style='color:red;'>交叉口模糊感应式信号控制的输入量是由输出量决定的。所以,其输出量是各个相位的绿灯时间长度或绿灯延时,显然在某一相位的红灯时间内,其对应的车道在停车线后的车辆排队数量越多,我们就希望这个相位下一个绿灯时间越长,反之,</span>希望下一个绿灯时间越短。</p><p>    <span style='color:red;'>本文研究的交叉口模糊感应式信号控制器是两个输入变量,一个输出变量。两个输入变量分别是当前相位的车辆通过数量Di以及下一个相位的车辆排队长度Yi+1,当前相位绿灯延时T是输出变量。下面两节均以Di、</span>Yi+1、T来表示两输入变量和一输出变量。<br />5.4.2输入、输出变量的模糊化</p><p>    <span style='color:red;'>输入、输出变量的模糊化处理分为两步:先确定合理确定输入、输出量的论语,然后再进行模糊化。<br />1、</span>输出、输出量的论域确定</p><p>    <span style='color:red;'>根据前面的分析,相位A、B的车辆数应该是2个车道车辆数的综合,而各路口都设置有2个相位100cm 的车辆检测器,</span>考虑到车辆安全停放的间距、小车车身长度(其他长的车辆长度都换成小车长度)等,<span style='color:red;'>将车辆排队长度输入变量Yi+1的变化范围设定为0~40,其基本论域是[0,40];按1辆/秒的车辆驶离率,通行相位车辆通过输入变量Di的变化设定为0~60,其基本论域是[0,60];输出变量T的变化范围设定为15~55,则其基本论域为[15,55]。</span></p><p>    <span style='color:red;'>因为排队长度不可能出现负数,所以经过量化之后输出变量Di、Yi+1的量化论域为:<br />Di={0,1,2,3,4,5,6,7,</span>8,9,10}</p><p>    输出变量T的量化论域选定为:</p><p>    Yi+1={0,1,2,3,4,5,6,7,8,9,10}</p><p>    2、确定量化因子及比例因子</p><p>    <span style='color:red;'>根据两个输入量的变化范围和量化后选定的输出量的论域关系,可得Di,Yi+1的量化因子分别为:<br />K1=(10-0)/(60-0)=0.17</span></p><p>    K2=(10-0)/(40-0)=0.25</p><p>    T的比例因子为:</p><p>    K=(55-15)/(10-0)=4</p><p>    3、模糊化</p><p>    (1)模糊语言值</p><p>    模糊语言变量的语言值在选择时候,既要简单又要考虑到控制的成效。<span style='color:red;'>一个模糊语言变量选中2~10个语言值是比较合适的。我们将语言变量Di、Yi+1的模糊子集定义为:</span></p><p>    <span style='color:red;'>Yi+1=Di={O,NB,NS,NM,PM,PS,PB},分别对应{零,很少,较少,少,多,较多,很多}的模糊概念。<br />语言变量T的模糊子集定义为:</span></p><p>    <span style='color:red;'>T={ES,VS,S,M,L,VL,EL},分别对应{极小,很小,小,中,大,很大,</span>极大}的模糊概念。<br />(2)隶属度函数</p><p>    ①输入语言变量Di的隶属度函数</p><p>    <span style='color:red;'>可用两种方法进行隶属度函数,图形表示法和表格表示法。</span></p><p>    图形表示法:</p><p>    <span style='color:red;'>输入语言变量Di在前面选取了O,NB,NS,NM,PM,PS,PB这7个值,它在整数论域分布如图:<br /></span>表格表示法:</p><p>    ②下一排队长度Yi+1的隶属度函数</p><p>    图形表示法:</p><p>    输入语言变量Yi+1在证书论域分布如图:</p><p>    表格表示法:</p><p>    ③绿灯延时时间T隶属度函数</p><p>    图形表示法:</p><p>    表格表示法:</p><p>    5.4.3模糊规则的设计</p><p>    <span style='color:red;'>建立模糊控制规则表的基本思想是:综合考虑交叉路口下一相位等待车辆的排队长度及当前相位延误车辆的排队长度,使车辆通过交叉路口的总延误尽可能小,具体如下:</span></p><p>    <span style='color:red;'>(1)当前相位的延误车辆数多、下一相位的等待车辆排队长度也是较多时,绿灯的延时T不是选定与当前相位的延误车辆数一样级别的调节量,而是选定低一级的模糊语言,以免下一相位车辆会等待太长的时间。</span></p><p>    <span style='color:red;'>(2)两个相位对应方向的状态为少以下的同一量级时,绿灯的延时T取&quot;小&quot;(S),其目的是在双方流量相差不多的情况下、尽快地均衡疏散。</span></p><p>    <span style='color:red;'>(3)当前相位驶离路口的车辆数较多、下一相位等待通过的车辆排队长度较少时,绿灯的延时控制量T取相对较大的调节量,使当前相位的车辆尽可能多的通过,而下一相位延误的车辆又不至于太多。</span></p><p>    <span style='color:red;'>(4)当前相位驶离路口的车辆数较少时,说明当前相位等待通过的车辆已经比较少,绿灯的延时控制量T取相对小的调节量,以便尽快进入下一相位。</span></p><p>    <span style='color:red;'>(5)当前相位驶离路口的车辆数是&quot;零&quot;,下一相位等待通过的车辆排队长度是&quot;很长&quot;,这种情形是不可能出现的。</span>反过来也是如此。<span style='color:red;'>根据交警的工作经验及相关知识,设计出绿延时模糊控制规则,如下表所示,&quot;&mdash;&quot;表示不可能出现的情况。</span></p><p>    <span style='color:red;'>该表包含了44条模糊条件语句,每一种情况下的一个控制策略用一条模糊条件语句代表。<br /></span>5.4.4信号灯模糊控制算法的具体描述</p><p>    <span style='color:red;'>步骤1:分别事先设定好相位A、相位B的Gmin(绿灯的最小时间)与Gmax(绿灯的最长时间</span>),确定好绿灯的延时增加值T、车辆排队长度的范围;</p><p>    <span style='color:red;'>步骤2:根据交叉口交通流的实际情况和交警工作经验,确定好模糊控制规则库;<br />步骤3:确定开始相位的绿灯通行权;</span></p><p>    步骤4:赋以通行相位最小的绿灯通行时长Gmin;</p><p>    <span style='color:red;'>步骤5:在绿灯通行时刻末,根据车辆检测器送来的检测数据,计算出当前放行相位的延误车辆数、另一个相位的车辆排队长度,分别用Di、Yi+1表示;</span></p><p>    <span style='color:red;'>步骤6:按照Di、Yi+1值的大小,根据模糊控制规则库,先确定当前通行相位绿灯延时T1,并判别Gmin+T1与Gmax的大小来修正实际绿灯延时时间值:</span></p><p>    <span style='color:red;'>若Gmin+T1&lt; Gmax,当前通行相位的绿灯延时为T1值、继续下一步骤;否则当前通行相位的实际绿灯延时T= Gmax- Gmin,并在绿灯延时时间到后,切换至下一相位通行、执行步骤4;</span></p><p>    <span style='color:red;'>步骤7:如绿灯延时T1结束前5秒内,当前通行相位无车辆通过,则在绿灯延时时间到后,切换至下一相位、执行步骤4。否则查模糊控制响应表确定再一次绿延时时间T2。若Gmin十T1+T2&lt; Gmax,则当前通行相位继续延时T2;反之其实际绿灯延时T= Gmax-Gmin- T1;当延时结束,切换至下一相位通行,</span>执行步骤4。<br />信号灯模糊控制算法流程图如图。</p><p>    6交通信号模糊控制的仿真实现</p><p>    6.1仿真软件简介</p><p>    6.2基于MATLAB的交通信号模糊控制</p><p>    交通控制仿真软件设计是上世纪60年代开始进行使用的交通控制研究方法,是交通工程中极为重要的领域。通过计算机所建立的数字模型,可以复现交通流时间和空间上的变化。本设计使用Matlab来进行仿真和对比验证。整个仿真模型由随机车流发生模型,交通信号控制模型和车辆延误计算模型三个部分组成。<br />6.1随机车流发生模型</p><p>    车流是本次仿真的基础,现实生活中交叉路口的车流到达是随机的、离散的。车流的到达是个比较复杂的随机过程,因此只有通过大范围长时间的统计才能得到规律。<span style='color:red;'>一般一个观察周期内,交通流的到达车辆数一般符合泊松分布或者二项分布。泊松分布用于描述时间间隔短,车流密度不大,</span>车辆相互间的干扰比较小的车流。二项分布用于描述车流密度大,车辆较少有自由行使机会的车流。<br />泊松分布的计算公式为:</p><p>    <span style='color:red;'>Px=(&lambda;t)xe-&lambda;tx!</span></p><p>    <span style='color:red;'>其中P(x)是指单位计时时间t内到达x辆车的概率,&lambda;表示单位时间车辆的平均到达率。则&lambda;t表示的是计时时间t内平均到达的车辆数。<br /></span>二项分布的计算公式为:</p><p>    Px=CnxPx(1-p)n-x</p><p>    其中n、p是分布参数,p=&lambda;tn表示某一辆车出现的概率,0&lt;p&lt;1。n为正整数,表示单位时间t内可到达的最大车辆数。<br />所以,根据车流密度的大小,建立如下框图所示的随机车流产生模型:</p><p>    6.2交通信号控制模型</p><p>    交通信号控制模型由3个模糊逻辑控制器组成,<span style='color:red;'>因此利用Matlab的模糊逻辑工具箱(Fuzzy logic Toolbox)中的FIS Editor Gui来进行设计。</span></p><p>    以绿灯相位交通强度模块的设计为例子,本设计定义了两个输入变量(当前排队超度queue和车流到达率rate),一个输出变量(模糊交通强度值TRgreen)。在这个页面可以编辑各个逻辑规则方法,其中模糊逻辑方法(Defuzzification)选择重心法,其余为默认设置,界面如下:</p><p>    <span style='color:red;'>双击其中任一变量,可进入隶属度函数编辑界面,在此界面中可以编辑各变量隶属度函数,例如论域(Range),</span>隶属度函数类型(Type,本设计中为三角型&quot;trimf&quot;)以及函数参数(Params),如下图所示</p><p>    双击上图中间方框,即可进入逻辑推理规则的编辑界面(本次设计采用&quot;mamdani&quot;型推理)。在该界面中,可编辑逻辑规则。逻辑规则为&quot;If-Then&quot;形式,本次设计中每个变量有5个隶属度函数,<span style='color:red;'>因此共有25条规则,通过&quot;Delete rule&quot;、&quot;Add rule&quot;和&quot;change rule&quot;按钮可进行删除、增加和编辑规则的操作,</span>如下图所示:</p><p>    按照上述方法分别生成GreenLntensity,RedLntensitu和Control三个fis文件,分别对应三个模块。在仿真程序中通过readfis命令和evalfis命令可以调用这三个模块。<br />6.3车流延误计算模型</p><p>    延误是评价交叉口通行效率的重要指标,通过这一指标还可以计算出诸如尾气排放量,燃油消耗等指标。因本次设计中,绿灯时间不固定,周期亦不固定,因此前人理论中的计算延误的模型已不再适用,需要建立新的延误计算模型。</p><p>    根据延误的定义,首先计算总延误。设周期开始时,<span style='color:red;'>每一车道已有排队车辆数为q0,则在∆t内红灯相位每一车道的排队车辆数为<br />Qr=q0+∆t∙&lambda;</span></p><p>    设∆t内每一车道离去车辆数为qL,绿灯相位每一车道的排队车辆数为:</p><p>    Qg=q0+∆t∙&lambda;-qL</p><p>    其中&lambda;为车辆到达率,设绿灯相位车道数为Ng,红灯相位车道数为Nr,则在∆t内总延误D为:<br />D=∆t∙(Ng∙Qg+Nr∙Qr)</p><p>    设周期为T,则一个周期的平均延误d为</p><p>    d=D∙T∆ti=1T∆tNg∙qL</p><p>    7结论</p><p>    设置仿真参数如下:时间间隔长度:4s;每车道最大排队数量:20辆;每相位开始时损失时间:4s;最小绿灯时长:8s;最大绿灯时长:40s;<span style='color:red;'>每车道初始排队车辆:1辆;驶离率:1辆/s;</span>仿真时长3600s。车道设置为每相位每方向分为直行和右转车道,左转车道两个车道。</p><p>    在产生相同的车流的情况下分别应用定时配时方案和本方案,得到如下控制效果对比:</p><p>    定时感应平均延误为51.93,本设计为则为24.135,整体效率提高53%左右。若应用本系统,可使得通行效率大幅提升。</p><p>    本设计也有一定的不足,在仿真中通过统计周期次数发现,本设计中在固定时长内周期数约为定时配时方案的两倍。这说明本设计的周期长度小于定时配时方案,这意味着相位切换的速度较快,在极端条件下可能导致停车次数大幅增加。<br />目前还有一种基于FDES(模糊离散事件系统)的交通控制系统,其系统运行效率相比于定时配时最高可达80%以上。本系统相比之下,仍需要改善和调整。</p><p class='uncheck'>参考文献、脚注、尾注</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    [1]何立民．单片机高级教程[M]．北京:北京航空航天大学出版社，2003</p><p class='uncheck'>    </p><p class='uncheck'>    [2]李学海.《标准80C51单片机基础教程：原理篇》 [M].北京航天航空出版社.2006</p><p class='uncheck'>    </p><p class='uncheck'>    [3]贾好来.《MSC—51 单片机原理及应用》 机械工业出版社，2007</p><p class='uncheck'>    </p><p class='uncheck'>    [4]谭浩强.《C语言设计与开发技术》北京清华出版社,1991</p><p class='uncheck'>    </p><p class='uncheck'>    [5]刘秀英.《单片机应用设计200例》 北京航天航空出社,2006</p><p class='uncheck'>    </p><p class='uncheck'>    [6]蒋红，朱兆优. 基于单片机的定时器.</p><p class='uncheck'>    </p><p class='uncheck'>    [7]贾立斌，谭青. 一种基于单片机的多位LED显示系统的计.</p><p class='uncheck'>    </p><p class='uncheck'>    [8]沈正元. 便携式多功能计时器_计数器.</p><p class='uncheck'>    </p><p class='uncheck'>    [9]何业军，李超.基于单片机控制的高精度定时打铃器的设计[J]电子技术.</p><p class='uncheck'>    </p><p class='uncheck'>    [10]李祝莲，熊耀恒. 高精度事件计时器的设计与实现.</p><p class='uncheck'>    </p><p class='uncheck'>    [11]陈忠孝.《单片机原理与应用》 西北大学出版社，2011.</p><p class='uncheck'>    </p><p class='uncheck'>    [12]李华.《MCS-51系列单片机实用接口技术》 北京航空航天大学出版社，1990.</p><p class='uncheck'>    </p><p class='uncheck'>    [13]楼然苗.单片机课程设计指导[M]. 北京：北京航空航天大学出版社，2007.7</p><p class='uncheck'>    </p><p class='uncheck'>    [14]朱思荣．51单片机实现公历与农历、星期的转换[Z].当当电子网</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    [15]Verghese G C, Lang H, Casey L F. Analysis of instability in electrical machines. IEEE Trans on IA, 1986, 22 :853-864 .</p><p class='uncheck'>    </p><p class='uncheck'>    [16]Richard Blanchard, James Harden. Mosfets control more power in the same-sized package .Electronic Design, 1982, 12 :107~114</p><p class='uncheck'>    </p><p class='uncheck'>    [17] Tiina Havana. 2003 April. Communication in the Software Vulnerability </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    致谢</p><p class='uncheck'>    </p><p class='uncheck'>    完成这次设计及这篇论文以后我大学生涯也即将结束，在做此次设计的日子里我得到了指导教师的悉心指导，在此向我的指导教师贺老师致以诚挚的谢意。也同时感谢在此次设计过程中帮助我的同学，在我对相关软件使用一筹莫展时，你们给我提供了相关的资料，给了我很多无私的帮助和支持，我在此深表谢意。没有你们的帮助，我不可能顺利地完成大学的学习，更不可能完成本次毕业设计。我要由衷地感谢指导老师老师和答辩老师给予的意见和建议，感谢同学给予的帮助。这次设计让学习掌握MATLAB/SIMULINK软件的基本用法，进而掌握其中模糊工具箱的用法，用MATLAB/SIMULINK软件对传统的交通信号定时控制方法和本文研究的模糊控制方法进行建模仿真，依据仿真结果对两种控制方法进行评价。在这次毕业设计中通过查找大量的模糊控制、交通信号灯控制的相关资料，锻炼了文献检索的能力，资料的整合能力，提高了分析设计能力。同时积累了模糊控制思维的相关经验和动手能力。本设计将书本知识和实物结合在了一起，提高了我查找相关资料和撰写论文的能力，培养了认真的态度和分析解决问题的能力，培养了耐心，以及做一件事要持之以恒，这一次的设计经历会对今后的学习和工作产生积极重大的影响。</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    毕业设计（论文）知识产权声明</p><p class='uncheck'>    </p><p class='uncheck'>    本人完全了解西安工业大学北方信息工程学院有关保护知识产权的规定，即：本科学生在校攻读学士学位期间毕业设计（论文）工作的知识产权属于西安工业大学信息工程学院。本人保证毕业离校后，使用毕业设计（论文）工作成果或用毕业设计（论文）工作成果发表论文时署名单位仍然为西安工业大学信息工程学院。学校有权保留送交的毕业设计（论文）的原文或复印件，允许毕业设计（论文）被查阅和借阅；学校可以公布毕业设计（论文）的全部或部分内容，可以采用影印、缩印或其他复制手段保存毕业设计（论文）。</p><p class='uncheck'>    </p><p class='uncheck'>    （保密的毕业设计（论文）在解密后应遵守此规定）</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    毕业设计（论文）作者签名：</p><p class='uncheck'>    </p><p class='uncheck'>    指导教师签名：</p><p class='uncheck'>    </p><p class='uncheck'>    日期：</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    毕业设计（论文）独创性声明</p><p class='uncheck'>    </p><p class='uncheck'>    秉承学校严谨的学风与优良的科学道德，本人声明所呈交的毕业设计（论文）是我个人在导师指导下进行的研究工作及取得的研究成果。尽我所知，除了文中特别加以标注和致谢的地方外，毕业设计（论文）中不包含其他人已经发表或撰写过的成果，不包含他人已申请学位或其他用途使用过的成果。与我一同工作的同志对本研究所做的任何贡献均已在论文中作了明确的说明并表示了致谢。</p><p class='uncheck'>    </p><p class='uncheck'>    毕业设计（论文）与资料若有不实之处，本人承担一切相关责任。</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    毕业设计（论文）作者签名：</p><p class='uncheck'>    </p><p class='uncheck'>    指导教师签名：</p><p class='uncheck'>    </p><p class='uncheck'>    日期：</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    附录1 仿真流程图</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    附录2 源程序清单</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    I 初始化</p><p class='uncheck'>    </p><p class='uncheck'>    global phaseA;</p><p class='uncheck'>    </p><p class='uncheck'>    global phaseB;</p><p class='uncheck'>    </p><p class='uncheck'>    global phaseC;</p><p class='uncheck'>    </p><p class='uncheck'>    global phaseD;</p><p class='uncheck'>    </p><p class='uncheck'>    global queue;</p><p class='uncheck'>    </p><p class='uncheck'>    global period;</p><p class='uncheck'>    </p><p class='uncheck'>    global min_green;</p><p class='uncheck'>    </p><p class='uncheck'>    global max_green;</p><p class='uncheck'>    </p><p class='uncheck'>    global sim_time;</p><p class='uncheck'>    </p><p class='uncheck'>    global sim_time_set;</p><p class='uncheck'>    </p><p class='uncheck'>    global cur_phase;</p><p class='uncheck'>    </p><p class='uncheck'>    global period_green;</p><p class='uncheck'>    </p><p class='uncheck'>    global cars_arri;</p><p class='uncheck'>    </p><p class='uncheck'>    global greenlist;</p><p class='uncheck'>    </p><p class='uncheck'>    global redlist;</p><p class='uncheck'>    </p><p class='uncheck'>    global control_list;</p><p class='uncheck'>    </p><p class='uncheck'>    phaseA = 1;</p><p class='uncheck'>    </p><p class='uncheck'>    phaseB = 2;</p><p class='uncheck'>    </p><p class='uncheck'>    phaseC = 3;</p><p class='uncheck'>    </p><p class='uncheck'>    phaseD = 4;</p><p class='uncheck'>    </p><p class='uncheck'>    queue = ones(8,1);</p><p class='uncheck'>    </p><p class='uncheck'>    period = 4;</p><p class='uncheck'>    </p><p class='uncheck'>    min_green = 8;</p><p class='uncheck'>    </p><p class='uncheck'>    max_green = 40;</p><p class='uncheck'>    </p><p class='uncheck'>    sim_time = 0;</p><p class='uncheck'>    </p><p class='uncheck'>    sim_time_set = 3600;</p><p class='uncheck'>    </p><p class='uncheck'>    cur_phase = phaseA;</p><p class='uncheck'>    </p><p class='uncheck'>    cur_phase_green = 0;</p><p class='uncheck'>    </p><p class='uncheck'>    period_green = 0;</p><p class='uncheck'>    </p><p class='uncheck'>    avg_green = 40;</p><p class='uncheck'>    </p><p class='uncheck'>    round_count = 1;</p><p class='uncheck'>    </p><p class='uncheck'>    round_time = 0;</p><p class='uncheck'>    </p><p class='uncheck'>    round_car_left = 0;</p><p class='uncheck'>    </p><p class='uncheck'>    total_wait_time = 0;</p><p class='uncheck'>    </p><p class='uncheck'>    avr_wait_time = 0;</p><p class='uncheck'>    </p><p class='uncheck'>    cars_left_total = 0;</p><p class='uncheck'>    </p><p class='uncheck'>    greenlist = green();</p><p class='uncheck'>    </p><p class='uncheck'>    redlist = red();</p><p class='uncheck'>    </p><p class='uncheck'>    control_list = control(greenlist,redlist);</p><p class='uncheck'>    </p><p class='uncheck'>    cars_arri = car_reach();</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    II 车辆到达函数</p><p class='uncheck'>    </p><p class='uncheck'>    cars_arri = zeros(8,900);</p><p class='uncheck'>    </p><p class='uncheck'>    for k = 1:12</p><p class='uncheck'>    </p><p class='uncheck'>     for i = 1:8</p><p class='uncheck'>    </p><p class='uncheck'>     for j = (((k-1)*75)+1):75*k</p><p class='uncheck'>    </p><p class='uncheck'>     if rate(k,i) <= 0.4</p><p class='uncheck'>    </p><p class='uncheck'>     cars_arri(i,j) = poissrnd(4*rate(k,i));</p><p class='uncheck'>    </p><p class='uncheck'>     else</p><p class='uncheck'>    </p><p class='uncheck'>     cars_arri(i,j) = binornd(5,rate(k,i));</p><p class='uncheck'>    </p><p class='uncheck'>     end</p><p class='uncheck'>    </p><p class='uncheck'>     end</p><p class='uncheck'>    </p><p class='uncheck'>     end</p><p class='uncheck'>    </p><p class='uncheck'>    end</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    III 模糊控制计算（以绿灯相位为例）</p><p class='uncheck'>    </p><p class='uncheck'>    TRgreen = readfis(‘GreenIntensity’);</p><p class='uncheck'>    </p><p class='uncheck'>    greenlist = zeros(21,11);</p><p class='uncheck'>    </p><p class='uncheck'>    for i = 1:1:21;</p><p class='uncheck'>    </p><p class='uncheck'>     for j = 1:11;</p><p class='uncheck'>    </p><p class='uncheck'>     rate = (j-1)/10;</p><p class='uncheck'>    </p><p class='uncheck'>     queue = i-1;</p><p class='uncheck'>    </p><p class='uncheck'>     greenlist(i,j) = evalfis([queue,rate],TRgreen);</p><p class='uncheck'>    </p><p class='uncheck'>     end</p><p class='uncheck'>    </p><p class='uncheck'>    end</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    IV模糊控制程序</p><p class='uncheck'>    </p><p class='uncheck'>    while sim_time < (sim_time_set-8)</p><p class='uncheck'>    </p><p class='uncheck'>     cur_phase_green = 0;</p><p class='uncheck'>    </p><p class='uncheck'>     sim_time = sim_time + min_green;</p><p class='uncheck'>    </p><p class='uncheck'>     cur_phase_green = cur_phase_green + min_green;</p><p class='uncheck'>    </p><p class='uncheck'>     queue = queue + cars_arri(:,sim_time/4 - 1)+cars_arri(:,sim_time/4);</p><p class='uncheck'>    </p><p class='uncheck'>     for i_pos = 1:8</p><p class='uncheck'>    </p><p class='uncheck'>     if queue(i_pos,1) > 20</p><p class='uncheck'>    </p><p class='uncheck'>     queue(i_pos,1) = 20;</p><p class='uncheck'>    </p><p class='uncheck'>     end</p><p class='uncheck'>    </p><p class='uncheck'>     end</p><p class='uncheck'>    </p><p class='uncheck'>     car_left = zeros(8,1);</p><p class='uncheck'>    </p><p class='uncheck'>     if cur_phase_green = min_green</p><p class='uncheck'>    </p><p class='uncheck'>     car_left(cur_phase,1) = min(min_green,queue(cur_phase,1));</p><p class='uncheck'>    </p><p class='uncheck'>     car_left(cur_phase+4,1) = min(min_green,queue(cur_phase+4,1));</p><p class='uncheck'>    </p><p class='uncheck'>     else</p><p class='uncheck'>    </p><p class='uncheck'>     car_left(cur_phase,1) = min(period,queue(cur_phase,1));</p><p class='uncheck'>    </p><p class='uncheck'>     car_left(cur_ohase+4,1) = min(period,queue(cur_phase+4,1));</p><p class='uncheck'>    </p><p class='uncheck'>     end</p><p class='uncheck'>    </p><p class='uncheck'>     cars_left_total = cars_left_total + sum(car_left);</p><p class='uncheck'>    </p><p class='uncheck'>     round_car_left = round_car_left + sum(car_left);</p><p class='uncheck'>    </p><p class='uncheck'>     queue = queue - car_left;</p><p class='uncheck'>    </p><p class='uncheck'>     total_wait_time = queue*4 + total_wait_time;</p><p class='uncheck'>    </p><p class='uncheck'>     while (cur_phase_green< max_green)&&(sim_time < sim_time_set)&&(control_list(max(cur_phase,1),queue(cur_phase_4,1))+1,round(10*rate(floor(sim_time/300)+1,((queue(cur_phase)>=queue(cur_phase+4))*cur_phase+(queue(cur_phase)<queue(cur_phase+4))*(cur_phase+4))))+1,max(queue(((cur_phase==4)*(phaseA+4)+(cur_phase~=4)*(cur_phase+5)),1))+1)<0.5)</p><p class='uncheck'>    </p><p class='uncheck'>     sim_time = sim_time + period;</p><p class='uncheck'>    </p><p class='uncheck'>     cur_phase_green = cur_phase_green + period;</p><p class='uncheck'>    </p><p class='uncheck'>     queue = queue + cars_arri(:,sim_time/4);</p><p class='uncheck'>    </p><p class='uncheck'>     for i_phase = 1:8</p><p class='uncheck'>    </p><p class='uncheck'>     if queue(i_phase,1) > 20</p><p class='uncheck'>    </p><p class='uncheck'>     queue(i_phase,1) = 20;</p><p class='uncheck'>    </p><p class='uncheck'>     end</p><p class='uncheck'>    </p><p class='uncheck'>     end</p><p class='uncheck'>    </p><p class='uncheck'>     car_left = zeros(8,1);</p><p class='uncheck'>    </p><p class='uncheck'>     if cur_phase_green == min_green</p><p class='uncheck'>    </p><p class='uncheck'>     car_left(cur_phase,1) = min(min_green,queue(cur_phase,1));</p><p class='uncheck'>    </p><p class='uncheck'>     car_left(cur_phase+4,1) = min(min_green,queue(cur_phase+4,1));</p><p class='uncheck'>    </p><p class='uncheck'>     else</p><p class='uncheck'>    </p><p class='uncheck'>     car_left(cur_phase,1) = min(period,queue(cur_phase,1));</p><p class='uncheck'>    </p><p class='uncheck'>     car_left(cur_phase+4,1) = min(period,queue(cur_phase+4,1));</p><p class='uncheck'>    </p><p class='uncheck'>     end</p><p class='uncheck'>    </p><p class='uncheck'>     if cur_phase == phaseD</p><p class='uncheck'>    </p><p class='uncheck'>     cur_phase = phaseA;</p><p class='uncheck'>    </p><p class='uncheck'>     avr_wait_time = sum(total_wait_time)/round_car_left;</p><p class='uncheck'>    </p><p class='uncheck'>     disp(avr_wait_time)</p><p class='uncheck'>    </p><p class='uncheck'>     round_count = round_count + 1;</p><p class='uncheck'>    </p><p class='uncheck'>     round_car_left = 0;</p><p class='uncheck'>    </p><p class='uncheck'>     total_wait_time = 0;</p><p class='uncheck'>    </p><p class='uncheck'>     else</p><p class='uncheck'>    </p><p class='uncheck'>     cur_phase = cur_phase + 1;</p><p class='uncheck'>    </p><p class='uncheck'>     end</p><p class='uncheck'>    </p><p class='uncheck'>    end</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    V 定时配时程序</p><p class='uncheck'>    </p><p class='uncheck'>    while sim_time < sim_time_set</p><p class='uncheck'>    </p><p class='uncheck'>     cur_phase_green = 0;</p><p class='uncheck'>    </p><p class='uncheck'>     sim_time = sim_time + max_green;</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>     while(cur_phase_green < max_green)&&(sim_time < sim_time_set)</p><p class='uncheck'>    </p><p class='uncheck'>     cur_phase_green = cur_phase_green + period;</p><p class='uncheck'>    </p><p class='uncheck'>     queue = queue + cars_arri(:,sim_time/4);</p><p class='uncheck'>    </p><p class='uncheck'>     for i_phase = 1:8</p><p class='uncheck'>    </p><p class='uncheck'>     if queue(i_phase,1) > 20</p><p class='uncheck'>    </p><p class='uncheck'>     queue(i_phase,1) = 20;</p><p class='uncheck'>    </p><p class='uncheck'>     end</p><p class='uncheck'>    </p><p class='uncheck'>     end</p><p class='uncheck'>    </p><p class='uncheck'>     car_left = zeros(8,1);</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>     car_left(cur_phase,1) = min(period,queue(cur_phase.1));</p><p class='uncheck'>    </p><p class='uncheck'>     car_left(cur_phase+4,1) = min(period,queue(cur_phase+4,1));</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>     queue = queue - car_left;</p><p class='uncheck'>    </p><p class='uncheck'>     total_wait_time = queue*4 + total_wait_time;</p><p class='uncheck'>    </p><p class='uncheck'>     cars_left_total = cars_left_total + sum(car_left);</p><p class='uncheck'>    </p><p class='uncheck'>     round_car_left = round_car_left + sum(car_left);</p><p class='uncheck'>    </p><p class='uncheck'>     end</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>     if cur_phase == phaseD</p><p class='uncheck'>    </p><p class='uncheck'>     cur_phase = phaseA;</p><p class='uncheck'>    </p><p class='uncheck'>     avr_wait_time = sum(total_wait_time)/round_car_left;</p><p class='uncheck'>    </p><p class='uncheck'>     disp(avr_wait_time)</p><p class='uncheck'>    </p><p class='uncheck'>     round_count = round_count + 1;</p><p class='uncheck'>    </p><p class='uncheck'>     round_car_left = 0;</p><p class='uncheck'>    </p><p class='uncheck'>     total_wait_time = ;</p><p class='uncheck'>    </p><p class='uncheck'>     else</p><p class='uncheck'>    </p><p class='uncheck'>     cur_phase = cur_phase + 1;</p><p class='uncheck'>    </p><p class='uncheck'>     end</p><p class='uncheck'>    </p><p class='uncheck'>    end</p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    </p><p class='uncheck'>    附录3 外文原文及翻译</p><br />
</body>
</html>

